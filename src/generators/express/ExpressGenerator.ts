import type { Project, FlowNode, EndpointConfig, DatabaseConfig, AuthConfig } from '../../types';

interface GeneratedFile {
    path: string;
    content: string;
}

interface RouteInfo {
    method: string;
    path: string;
    handler: string;
    middleware: string[];
    description: string;
}

export class ExpressGenerator {
    private project: Project;
    private routes: RouteInfo[] = [];

    constructor(project: Project) {
        this.project = project;
    }

    generate(): GeneratedFile[] {
        const files: GeneratedFile[] = [];

        // Parse the graph and extract routes
        this.parseGraph();

        // Generate files
        files.push(this.generatePackageJson());
        files.push(this.generateServerFile());
        files.push(this.generateRoutesFile());
        files.push(this.generateControllersFile());
        files.push(this.generateModelsIndex());
        files.push(this.generateDbConnection());
        files.push(this.generateEnvExample());
        files.push(this.generateDockerfile());
        files.push(this.generateDockerCompose());
        files.push(this.generateRenderYaml());

        // Generate model files
        this.project.models.forEach(model => {
            files.push(this.generateModelFile(model.name, model.fields));
        });

        return files;
    }

    private parseGraph(): void {
        // Find all endpoint nodes and trace their connections
        const endpointNodes = this.project.nodes.filter(n => n.data.type === 'endpoint');

        endpointNodes.forEach(node => {
            const config = node.data.config as EndpointConfig;
            const connectedNodes = this.getConnectedNodes(node.id);

            const route: RouteInfo = {
                method: config.method.toLowerCase(),
                path: config.path,
                handler: this.generateHandlerName(config.path, config.method),
                middleware: [],
                description: config.description || `${config.method} ${config.path}`,
            };

            // Check for auth nodes in the chain
            const authNode = connectedNodes.find(n => n.data.type === 'auth');
            if (authNode) {
                const authConfig = authNode.data.config as AuthConfig;
                if (authConfig.type !== 'none') {
                    route.middleware.push('authMiddleware');
                }
            }

            this.routes.push(route);
        });
    }

    private getConnectedNodes(nodeId: string): FlowNode[] {
        const connectedIds = new Set<string>();

        // Find all edges connected to this node
        this.project.edges.forEach(edge => {
            if (edge.source === nodeId) connectedIds.add(edge.target);
            if (edge.target === nodeId) connectedIds.add(edge.source);
        });

        return this.project.nodes.filter(n => connectedIds.has(n.id));
    }

    private generateHandlerName(path: string, method: string): string {
        const cleanPath = path.replace(/[^a-zA-Z]/g, '_').replace(/_+/g, '_');
        return `${method.toLowerCase()}${cleanPath.charAt(0).toUpperCase()}${cleanPath.slice(1)}`;
    }

    private generatePackageJson(): GeneratedFile {
        const pkg = {
            name: this.project.name.toLowerCase().replace(/\s+/g, '-'),
            version: '1.0.0',
            description: this.project.description || 'Generated by Routify',
            main: 'src/server.js',
            scripts: {
                start: 'node src/server.js',
                dev: 'nodemon src/server.js',
            },
            dependencies: {
                express: '^4.18.2',
                mongoose: '^8.0.0',
                cors: '^2.8.5',
                dotenv: '^16.3.1',
                helmet: '^7.1.0',
                'express-rate-limit': '^7.1.5',
                'swagger-ui-express': '^5.0.0',
                jsonwebtoken: '^9.0.2',
                bcryptjs: '^2.4.3',
            },
            devDependencies: {
                nodemon: '^3.0.2',
            },
        };

        return {
            path: 'package.json',
            content: JSON.stringify(pkg, null, 2),
        };
    }

    private generateServerFile(): GeneratedFile {
        const content = `const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const swaggerUi = require('swagger-ui-express');
require('dotenv').config();

const connectDB = require('./config/db');
const routes = require('./routes');
const swaggerSpec = require('./swagger');

const app = express();
const PORT = process.env.PORT || ${this.project.settings.port};

// Connect to MongoDB
connectDB();

// Middleware
app.use(helmet());
app.use(cors({
  origin: ${JSON.stringify(this.project.settings.corsOrigins)},
  credentials: true,
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Swagger UI
app.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// API Routes
app.use('${this.project.settings.basePath}', routes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

app.listen(PORT, () => {
  console.log(\`ðŸš€ Server running on port \${PORT}\`);
  console.log(\`ðŸ“š Swagger docs at http://localhost:\${PORT}/docs\`);
});
`;

        return { path: 'src/server.js', content };
    }

    private generateRoutesFile(): GeneratedFile {
        const imports = `const express = require('express');
const router = express.Router();
const controllers = require('./controllers');
${this.routes.some(r => r.middleware.includes('authMiddleware')) ? "const { authMiddleware } = require('./middleware/auth');" : ''}
`;

        const routeDefinitions = this.routes.map(route => {
            const middleware = route.middleware.length > 0
                ? route.middleware.join(', ') + ', '
                : '';
            return `router.${route.method}('${route.path}', ${middleware}controllers.${route.handler});`;
        }).join('\n');

        const content = `${imports}
${routeDefinitions}

module.exports = router;
`;

        return { path: 'src/routes.js', content };
    }

    private generateControllersFile(): GeneratedFile {
        const handlers = this.routes.map(route => {
            // Find the endpoint node
            const endpointNode = this.project.nodes.find(n => {
                if (n.data.type !== 'endpoint') return false;
                const config = n.data.config as EndpointConfig;
                return config.path === route.path && config.method.toLowerCase() === route.method;
            });

            if (!endpointNode) return '';

            // Check for connected database node
            const connectedNodes = this.getConnectedNodes(endpointNode.id);
            const dbNode = connectedNodes.find(n => n.data.type === 'database');

            let handlerBody = '';
            if (dbNode) {
                const dbConfig = dbNode.data.config as DatabaseConfig;
                handlerBody = this.generateDbOperationCode(dbConfig, route.method);
            } else {
                handlerBody = `
    res.json({ message: '${route.description}' });`;
            }

            return `
// ${route.description}
exports.${route.handler} = async (req, res) => {
  try {${handlerBody}
  } catch (error) {
    console.error('Error in ${route.handler}:', error);
    res.status(500).json({ error: error.message });
  }
};`;
        }).filter(Boolean).join('\n');

        return { path: 'src/controllers.js', content: handlers };
    }

    private generateDbOperationCode(config: DatabaseConfig, _method: string): string {
        const modelName = config.model || 'Item';
        const ModelVar = modelName.charAt(0).toUpperCase() + modelName.slice(1);

        switch (config.operation) {
            case 'list':
                return `
    const items = await ${ModelVar}.find({});
    res.json(items);`;
            case 'read':
                return `
    const item = await ${ModelVar}.findById(req.params.id);
    if (!item) {
      return res.status(404).json({ error: '${modelName} not found' });
    }
    res.json(item);`;
            case 'create':
                return `
    const newItem = new ${ModelVar}(req.body);
    await newItem.save();
    res.status(201).json(newItem);`;
            case 'update':
                return `
    const item = await ${ModelVar}.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );
    if (!item) {
      return res.status(404).json({ error: '${modelName} not found' });
    }
    res.json(item);`;
            case 'delete':
                return `
    const item = await ${ModelVar}.findByIdAndDelete(req.params.id);
    if (!item) {
      return res.status(404).json({ error: '${modelName} not found' });
    }
    res.json({ message: '${modelName} deleted successfully' });`;
            default:
                return `
    res.json({ message: 'Operation: ${config.operation}' });`;
        }
    }

    private generateModelsIndex(): GeneratedFile {
        const imports = this.project.models.map(m =>
            `const ${m.name} = require('./${m.name.toLowerCase()}');`
        ).join('\n');

        const exports = this.project.models.map(m => `  ${m.name},`).join('\n');

        const content = `${imports}

module.exports = {
${exports}
};
`;

        return { path: 'src/models/index.js', content };
    }

    private generateModelFile(name: string, fields: Array<{ name: string; type: string; isRequired: boolean }>): GeneratedFile {
        const schemaFields = fields.map(f => {
            const mongoType = this.toMongoType(f.type);
            return `  ${f.name}: { type: ${mongoType}, required: ${f.isRequired} }`;
        }).join(',\n');

        const content = `const mongoose = require('mongoose');

const ${name}Schema = new mongoose.Schema({
${schemaFields}
}, {
  timestamps: true,
});

module.exports = mongoose.model('${name}', ${name}Schema);
`;

        return { path: `src/models/${name.toLowerCase()}.js`, content };
    }

    private toMongoType(type: string): string {
        const typeMap: Record<string, string> = {
            String: 'String',
            Int: 'Number',
            Float: 'Number',
            Boolean: 'Boolean',
            DateTime: 'Date',
            Json: 'mongoose.Schema.Types.Mixed',
        };
        return typeMap[type] || 'String';
    }

    private generateDbConnection(): GeneratedFile {
        const content = `const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log(\`MongoDB Connected: \${conn.connection.host}\`);
  } catch (error) {
    console.error('MongoDB connection error:', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;
`;

        return { path: 'src/config/db.js', content };
    }

    private generateEnvExample(): GeneratedFile {
        const content = `# Server
PORT=${this.project.settings.port}
NODE_ENV=development

# MongoDB
MONGODB_URI=mongodb://localhost:27017/${this.project.name.toLowerCase().replace(/\s+/g, '-')}

# JWT (if using authentication)
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=7d
`;

        return { path: '.env.example', content };
    }

    private generateDockerfile(): GeneratedFile {
        const content = `FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE ${this.project.settings.port}

CMD ["npm", "start"]
`;

        return { path: 'Dockerfile', content };
    }

    private generateDockerCompose(): GeneratedFile {
        const content = `version: '3.8'

services:
  app:
    build: .
    ports:
      - "${this.project.settings.port}:${this.project.settings.port}"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongo:27017/${this.project.name.toLowerCase().replace(/\s+/g, '-')}
    depends_on:
      - mongo

  mongo:
    image: mongo:7
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:
`;

        return { path: 'docker-compose.yml', content };
    }

    private generateRenderYaml(): GeneratedFile {
        const content = `services:
  - type: web
    name: ${this.project.name.toLowerCase().replace(/\s+/g, '-')}
    env: node
    buildCommand: npm install
    startCommand: npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: MONGODB_URI
        sync: false
      - key: JWT_SECRET
        generateValue: true
`;

        return { path: 'render.yaml', content };
    }
}
